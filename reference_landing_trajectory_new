import csv
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from scipy.optimize import minimize
from src.envs.utils.atmosphere_dynamics import endo_atmospheric_model
from src.envs.load_initial_states import load_landing_burn_initial_state


class reference_landing_trajectory:
    def __init__(self):
        # Constants
        sizing_results = {}
        with open('data/rocket_parameters/sizing_results.csv', 'r') as file:
            reader = csv.reader(file)
            for row in reader:
                sizing_results[row[0]] = row[2]
        Te = float(sizing_results['Thrust engine stage 1'])
        ne = 12
        self.T = Te * ne
        v_ex =  float(sizing_results['Exhaust velocity stage 1'])
        self.mdot_max = self.T/v_ex
        self.g_0 = 9.80665
        self.C_n_0 = 3
        self.S_grid_fin = 2
        self.n_grid_fin = 4
        self.dt = 0.1
        self.max_q = 50000 # [Pa]
        self.m_s = float(sizing_results['Structural mass stage 1 (descent)'])*1000
        
        # Logging
        self.a_vals = []
        self.m_vals = []
        self.y_vals = []
        self.v_vals = []
        self.tau_vals = []
        self.time_vals = []
        self.time = 0.0

        self.load_initial_conditions()
        self.find_dynamic_pressure_limited_velocities()
        self.compute_optimal_trajectory()
        self.post_process_results()
        
    def load_initial_conditions(self):
        state_initial = load_landing_burn_initial_state()
        self.y_0 = state_initial[1]
        v_x_0 = state_initial[2]
        self.v_y_0 = state_initial[3]
        self.v_0 = np.sqrt(v_x_0**2 + self.v_y_0**2)
        self.y_refs = np.linspace(self.y_0, 0, 100)
        # Initial conditions
        self.m = state_initial[8]
        self.y = self.y_0
        self.v = self.v_0

    def find_dynamic_pressure_limited_velocities(self):
        air_densities = np.zeros(len(self.y_refs))
        max_v_s = np.zeros(len(self.y_refs))

        for i, y_ref in enumerate(self.y_refs):
            air_densities[i], _, _ = endo_atmospheric_model(y_ref)
            max_v_s[i] = np.sqrt(2.0 * self.max_q / air_densities[i])

        self.v_max_fcn = np.poly1d(np.polyfit(self.y_refs, max_v_s, 4))
        # This is the acceleration to stay at max velocity limit in gs
        self.a_v_max_gs_fcn = np.gradient(self.v_max_fcn(self.y_refs), self.y_refs) * self.v_max_fcn(self.y_refs) # Chain rule dv/dt = dv/dy * dy/dt = dv/dy * v

    def compute_optimal_trajectory(self):
        # Compute a trajectory with the initial reference point being the altitude where a_v_max_gs_gcn is 5.5 gs
        # i.e. find y, where a = 5gs to stay at max dp, then the corresponding v_max
        # Then find the calculate the vmax to it, first by finding the burn time constraint by a max g of 5.5
        # a = -9.81 + T/m(t) * throttle
        # m(t) = m0 - mdot * dt * throttle

        # Then stay at the DP limit untill 5000m and throttle down to landing.